/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "StateSvr_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace protruly {


ST_SvrInfo::~ST_SvrInfo() throw() {
}


void ST_SvrInfo::__set_strSvrHost(const std::string& val) {
  this->strSvrHost = val;
}

void ST_SvrInfo::__set_uiThreadIdx(const int32_t val) {
  this->uiThreadIdx = val;
}

uint32_t ST_SvrInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_strSvrHost = false;
  bool isset_uiThreadIdx = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strSvrHost);
          isset_strSvrHost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uiThreadIdx);
          isset_uiThreadIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_strSvrHost)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_uiThreadIdx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ST_SvrInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ST_SvrInfo");

  xfer += oprot->writeFieldBegin("strSvrHost", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->strSvrHost);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uiThreadIdx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->uiThreadIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ST_SvrInfo &a, ST_SvrInfo &b) {
  using ::std::swap;
  swap(a.strSvrHost, b.strSvrHost);
  swap(a.uiThreadIdx, b.uiThreadIdx);
}

ST_SvrInfo::ST_SvrInfo(const ST_SvrInfo& other0) {
  strSvrHost = other0.strSvrHost;
  uiThreadIdx = other0.uiThreadIdx;
}
ST_SvrInfo& ST_SvrInfo::operator=(const ST_SvrInfo& other1) {
  strSvrHost = other1.strSvrHost;
  uiThreadIdx = other1.uiThreadIdx;
  return *this;
}
void ST_SvrInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ST_SvrInfo(";
  out << "strSvrHost=" << to_string(strSvrHost);
  out << ", " << "uiThreadIdx=" << to_string(uiThreadIdx);
  out << ")";
}


ST_UserInfo::~ST_UserInfo() throw() {
}


void ST_UserInfo::__set_member_id(const int32_t val) {
  this->member_id = val;
}

void ST_UserInfo::__set_channel(const int32_t val) {
  this->channel = val;
}

void ST_UserInfo::__set_type(const int32_t val) {
  this->type = val;
}

void ST_UserInfo::__set_session(const std::string& val) {
  this->session = val;
}

uint32_t ST_UserInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_member_id = false;
  bool isset_channel = false;
  bool isset_type = false;
  bool isset_session = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->member_id);
          isset_member_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->channel);
          isset_channel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session);
          isset_session = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_member_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_channel)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_session)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ST_UserInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ST_UserInfo");

  xfer += oprot->writeFieldBegin("member_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->member_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channel", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->channel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->session);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ST_UserInfo &a, ST_UserInfo &b) {
  using ::std::swap;
  swap(a.member_id, b.member_id);
  swap(a.channel, b.channel);
  swap(a.type, b.type);
  swap(a.session, b.session);
}

ST_UserInfo::ST_UserInfo(const ST_UserInfo& other2) {
  member_id = other2.member_id;
  channel = other2.channel;
  type = other2.type;
  session = other2.session;
}
ST_UserInfo& ST_UserInfo::operator=(const ST_UserInfo& other3) {
  member_id = other3.member_id;
  channel = other3.channel;
  type = other3.type;
  session = other3.session;
  return *this;
}
void ST_UserInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ST_UserInfo(";
  out << "member_id=" << to_string(member_id);
  out << ", " << "channel=" << to_string(channel);
  out << ", " << "type=" << to_string(type);
  out << ", " << "session=" << to_string(session);
  out << ")";
}


LoginResult::~LoginResult() throw() {
}


void LoginResult::__set_retCode(const int32_t val) {
  this->retCode = val;
}

void LoginResult::__set_info(const ST_UserInfo& val) {
  this->info = val;
}

uint32_t LoginResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_retCode = false;
  bool isset_info = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retCode);
          isset_retCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->info.read(iprot);
          isset_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_retCode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_info)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LoginResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LoginResult");

  xfer += oprot->writeFieldBegin("retCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->retCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("info", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LoginResult &a, LoginResult &b) {
  using ::std::swap;
  swap(a.retCode, b.retCode);
  swap(a.info, b.info);
}

LoginResult::LoginResult(const LoginResult& other4) {
  retCode = other4.retCode;
  info = other4.info;
}
LoginResult& LoginResult::operator=(const LoginResult& other5) {
  retCode = other5.retCode;
  info = other5.info;
  return *this;
}
void LoginResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LoginResult(";
  out << "retCode=" << to_string(retCode);
  out << ", " << "info=" << to_string(info);
  out << ")";
}


ST_MsgResult::~ST_MsgResult() throw() {
}


void ST_MsgResult::__set_retCode(const int32_t val) {
  this->retCode = val;
}

void ST_MsgResult::__set_jsData(const std::string& val) {
  this->jsData = val;
__isset.jsData = true;
}

uint32_t ST_MsgResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_retCode = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retCode);
          isset_retCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jsData);
          this->__isset.jsData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_retCode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ST_MsgResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ST_MsgResult");

  xfer += oprot->writeFieldBegin("retCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->retCode);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.jsData) {
    xfer += oprot->writeFieldBegin("jsData", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->jsData);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ST_MsgResult &a, ST_MsgResult &b) {
  using ::std::swap;
  swap(a.retCode, b.retCode);
  swap(a.jsData, b.jsData);
  swap(a.__isset, b.__isset);
}

ST_MsgResult::ST_MsgResult(const ST_MsgResult& other6) {
  retCode = other6.retCode;
  jsData = other6.jsData;
  __isset = other6.__isset;
}
ST_MsgResult& ST_MsgResult::operator=(const ST_MsgResult& other7) {
  retCode = other7.retCode;
  jsData = other7.jsData;
  __isset = other7.__isset;
  return *this;
}
void ST_MsgResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ST_MsgResult(";
  out << "retCode=" << to_string(retCode);
  out << ", " << "jsData="; (__isset.jsData ? (out << to_string(jsData)) : (out << "<null>"));
  out << ")";
}

} // namespace
